学习目标:
1. 书写简单正则表达式
2. 看懂正则表达式语法构成

声明正则表达式 - 构造函数/直接量
1. new RegExp( string, pattern );
2. /string/pattern;

说明:
pattern: i, g, m
i: ignorecase 不区分大小写
g: global 匹配到字符串结束
m: multiline 多行

例子:
/abc/i -> 匹配 'abc', 'Abc', 'ABc', 'ABC', 'aBc', 'aBC', 'abC'
RegExp 构造函数实例放到最后。


在学习中, 需要练习 - 下面介绍测试方法.
var reg = /a/ig;
var string = 'NBA';
// 1. 
reg.test( string );  // 返回 Boolean 值.
// 2. 
reg.exec( string );  // [ 'A' ] 返回数组.
// 3.
string.match( reg ); // [ 'A' ] 返回数组.


正则语法.
/a/  匹配单个字符 'a'
/ab/ 匹配两个字符 'ab'

/a|b/  匹配单个字符 'a' 或 'b'.   说明: '|' 字符表示或关系
/ab|bc/ 匹配两个字符 'ab' 或 'bc'. 相当于(ab)|(bc)
/z(ab|bc)/ 匹配三个字符 'zab' 或 'zbc'. 说明: 理解 '|' 字符两边的正则是什么!

/[ab]/ 匹配单个字符 'a' 或 'b'. 比写成 /a|b/更容易理解. 表示匹配[]字符对里面的单个字符。
/[^ab]/ 匹配除了 'a' 和 'b' 外的单个字符. [] 字符对里面的 ^ 字符表示排除关系。

/[0-9]/ 匹配单个数字字符. 为了方便书写而已, 要不然得写 10 个字符。
/[2-6]/ 这样写范围也可以。
/[0-9A-Za-z]/ 不单单数字, 字母也可以 - 区分 a-z, A-Z. 最后记住: 这里是匹配单个字符.
/[a-z]/i 这里使用 i 说明不区分大小写. 那它就相当于 [A-Za-z]。

/./ 匹配除换行符外任意一个字符. '.' 在正则里面有特殊意义.
/\./ 因为特殊, 所以要匹配它时, 就得转义它. 使用 \ 转义. 如果需要匹配 ], [, ), (, ^, | 上面出现的有特殊含义字符, 就得转义。
/\d/ 等于 [0-9]
/\D/ 等于 [^0-9]. 可以这样记: \D 和 \d 是互补的, 并且完全相反的.
/\w/ 等于 [0-9A-Za-z_] 字母、数字和下划线
/\W/ 等于 [^0-9A-Za-z_] 除 \w 以外的字符
/\s/ 空白字符
/\S/ 非空白字符
/[\s\S]/ 既然 \s 和 \S 是互补的, 那么 [\s\S] 即空白或非空白, 也就是任意一个字符.

/[\d]/ 匹配单个数字字符
/[.]/  匹配 '.' 字符本身。特殊字符在 [] 字符对里面就成了普通字符，也可以对它转义写成 /[\.]/。如果不确定怎么写时, 就加上转义字符。

以上都是匹配单个字符. 下面看匹配多个字符情况.
/a{3}/  匹配三个字符 - 'aaa'。 又出现特殊字符 { 和 }。
/a{3,}/ 匹配至少3个字符 - 'aaa', 'aaaaa', ....。
/a{3,6}/ 匹配至少3个字符, 但又不能超过6个字符. 'aaa', 'aaaa', 'aaaaa', 'aaaaaa'。

/\w{3}/ 匹配 'abc', 'xyx', '010' 等由三个 [0-9A-Za-z_] 字符组成的字符串.
/\d{11}/ 匹配 11 位数字, 比如手机号.

以上需要指定重复字符的个数, 而现实中往往是字符可选, 至少一个或者任意个数. 看下面新加的几个特殊符号 ? + *.
/a?/ 匹配 'a', ''。 表示 ? 字符前面的字符是可选的。
/a+/ 匹配至少一个字符 a, 相当于 /a{1,}/。 表示 + 前面的字符至少存在一个。
/a*/ 匹配任意个字符 a, 相当于 /a?|a{1,}/。表示 * 前面的字符可以是任意个数。

在上面三个特殊字符后再加个 ? 字符, 表示尽可能少的去匹配字符.
/a??b/ 优先匹配空, 不满足时, 再尝试匹配 a。 结果会匹配 'b' 字符.
/a+?/ 优先尝试匹配一个. /a+?/.test( 'aaaaaaa' ); // 结果只匹配第一个 'a' 字符.
/a*?b/ 优先匹配空字符, 不满足时, 再尝试匹配1个字符, 一次类推. /a*?b/.test( 'aab' ); 匹配 'aab'。

边界条件匹配 - 即只匹配位置, 不匹配字符.
/^a/ ^ 表示匹配字符串开头位置。 /^a/.test( 'abc' );(true) /^a/.test( 'baaaa' );(false)
/a$/ $ 表示匹配字符串结束位置。 /a$/.test( 'abc' );(false) /a$/.test( 'ba' ); (true)
/\ba/ \b 表示单词的边界.
	/\bgoogle\b/i.test( 'I love google' );(true)
	/\bgoogle\b/i.test( 'ILoveGoogle' );(false)
	单词的边界不一定是空格. 比如标点符号也是边界.
/\w(?=\d)|\d(?=\w)/
  (?=...) 需要在括号内, 并且以 ?= 开头, 表示后面满足.
  由于 | 的存在, 把上面正则分为两部分
    1. /\w(?=\d)/ 表示匹配字符, 并且下一位置的字符满足 \d。
    2. /\d(?=\w)/ 表示匹配数字, 并且下一位置的字符满足 \w。
/a(?!b)/
  (?!...) 和 (?=...) 类似, 但表示后面不满足.
  /a(?!b)/ 不匹配 'ab', 但匹配 'ac'

分组
/z(ab|bc)/ 这里 (ab|bc) 会被认为是一组. 并且正则会保存组匹配到的字符结果.
/('|")abc\1/ 如果存在组时, 可使用 \number 来代替已匹配组的内容. 这里匹配 "'abc'" 和 '"abc"'
有的时候, 只是需要使用括号, 而不是为了得到它匹配的结果. 比如 /z(ab|bc)/ 只是为了解决 | 特殊字符的问题. 那么可以写成这样:
/z(?:ab|bc)/ 即括号内以 ?: 开头.

正则表达式构造函数
需求：不区分大小写的匹配字母、数字和下划线。
直接量：/\w/
构造函数: new RegExp( '\\w', 'g' );
如果只使用一个 \ 的话, JavaScript 会把 \w 解析成单个字符 w. 结果为 new RegExp( 'w', 'g' );

问: JavaScript 里怎么使用这些正则表达式呢?
答: https://github.com/zhanhongtao/blog/issues/126

看几个例子
1. 把里面的"坏"字符去掉 'abc2defghijklmnopqrstu5vwxyz'. 坏这里指数字 -> 现实中可能是非法字符.
var string = 'abc2defghijklmnopqrstu5vwxyz';
var result = string.replace( /\d/g, '' );
2. 把 html 标签替换为实体字符.
var string = '<strong>strong</strong><b>B</b>'; // 不信任数据, 需要处理 html 标签.
string = string.replace( /&/g, '&amp;' )
  .replace( />/g, '&gt;' )
	.replace( /</g, '&lt;' );
document.write( string );
或
var codemap = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;'
};
var string = '<strong>strong</strong><b>B</b>'; // 不信任数据, 需要处理 html 标签.
string = string.replace( /[&<>]/g, function( match ) {
  return codemap[ match ];
});
document.write( string );

自己体会下.
/(\d)(?=(?:\d{3})+$)/g
  1. (\d)
  2. (?= ..... )
  3. (?:\d{3})+$
  '1234567890'.replace( /(\d)(?=(?:\d{3})+$)/g, '$1,' );
