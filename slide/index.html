<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>slide</title>
  <link rel="stylesheet" href="./css/base.css">
  <link rel="stylesheet" href="./css/app.css">
</head>
<body>
  <section class="slide slide-cover">
    <h1>深入浅出 JavaScript 函数</h1>
    <h2 class="h6">Sogou Browser - REDKY@qq.com</h2>
    <h3 class="h6"></h3>
  </section>
  <section class="slide">
    <h1>函数基础</h1>
    <ul>
      <li>函数定义</li>
      <li>函数参数和返回值</li>
      <li>函数调用</li>
      <li>匿名函数</li>
      <li>变量作用域 - 闭包</li>
      <li>其它 - 链式调用, 递归等</li>
    </ul>
  </section>
  <section class="slide">
    <h1>函数定义</h1>
    <dl>
      <dt>函数声明</dt>
      <dd><code>function getUserName( user ) {}</code></dd>
      <dt>函数表达式</dt>
      <dd><code>var getUserName = function( user ) {};</code></dd>
      <dt>基于构造函数</dt>
      <dd><code>var getUserName = new Function( 'user', 'return user.name;' );</code></dd>
    </dl>
  </section>
  <section class="slide">
    <h1>函数参数和返回值</h1>
    <h2 class="h4">参数</h2>
    <ul>
      <li>定义时, 参数可不写; 调用时, 使用 arguments 访问.</li>
      <li>形参[形式参数]: 参数个数 <code>getUserName.length</code></li>
      <li>实参[实际调用时参数]: 参数个数 <code>arguments.length</code></li>
      <li>调用时参数可为任意数据类型(包含 function)</li>
    </ul>
    <mark>参数传递值和引用 - JavaScript 和 c++</mark>
  </section>
  <section class="slide">
    <h1>函数参数和返回值</h1>
    <h2 class="h4">返回值</h2>
    <p>可返回何意数据类型</p>
    <p>提前结束函数 (forEach怎么提前退出?)</p>
    <div class="codebox">
<pre>
function foreach( array, func ) {
  try { array.forEach( func );}
  catch(e) {}
}
foreach( [1, 2, 3, 4], function( item, index ) {
  if ( index === 2 ) throw new Error( 'error' );
  alert( 'item value: ' + item );
});
alert( 'end' );
</pre>
  <div class="runcase">Run</div>
  </div>
  </section>
  <section class="slide">
    <h1>函数调用</h1>
    <dl>
      <dt>直接调用 - 最常用</dt>
      <dd><code>getUserName( user );</code></dd>
      <dt>方法调用</dt>
      <dd><code>extension.getUserName( user );</code></dd>
      <dt>使用 call/apply</dt>
      <dd><code>getUserName.call( extension, user );</code> </dd>
      <dd><code>getUserName.apply( extensioin, [user] );</code></dd>
      <dt>使用 new 关键字 - 常用于实例化对象</dt>
      <dd><code>new System();</code></dd>
    </dl>
  </section>
  <section class="slide">
    <h1>匿名函数</h1>
    <ul>
      <li><code>;(function() {})(); // 自执行</code></li>
      <li><code>var getUserName = function/*getUserName*/() {};</code></li>
      <li><code>element.addEventListener('click', function() {}, false );</code></li>
      <li><code>setTimeout(function() {}, 100); // setInterval</code></li>
      <li><code>'?path=p1'.replace(/[^?&]path=[^#&]*/i,function() {});</code></li>
      <li><code>[1,3,2].sort(function( a, b ) { return a - b;});</code></li>
      <li><code>function func(){return function() {};}</code></li>
      <li><code>promise().done(function() {}).fail(function() {}); // jQuery</code></li>
    </ul>
  </section>
  <section class="slide">
    <h1>实例 - bind</h1>
<pre>
  /**
    指定运行时 this.
    Function.prototype.bind
    * 修正 ie 早期版本 this 指向.
    * 函数作为回调时, 保证 this 指向.
  */
  function bind( func, context ) {
    return function() {
      return func.apply( context || this, arguments );
    };
  }
</pre>
  </section>
  <section class="slide">
    <h1>实例 - bind</h1>
<pre contenteditable="true">
  if ( document.attachEvent ) {
    // ie 早期版本的事件绑定.
    document.attachEvent( 'onclick', function() {
      alert( this );
    });
    document.attachEvent( 'onclick', bind(function() {
      alert( this );
    }, document);
  }
</pre>
  </section>
  <section class="slide">
    <h1>实例 - bind</h1>
    <div class="codebox">
<pre contenteditable="true">
var system = {
  name: 'sogou',
  runcase: function() {
    return !!this.name && this.name.indexOf( 'o' ) > -1;
  }
};
function getBrowserDataFromServer( cb ) {
  var data = { name: 'chrome' };
  return bind( cb, data )();
}
alert( getBrowserDataFromServer( system.runcase ) );
</pre>
      <div class="runcase">Run</div>
    </div>
  </section>
  <section class="slide">
    <h1>实例 - type</h1>
    <div class="codebox">
<pre contenteditable="true">
  // 求数据类型.
  function type( s ) {
    var classtype = Object.prototype.toString.call( s );
    return classtype.slice(8, -1).toLowerCase();
  }
  alert( [ type(1), type('')] );
  alert( [ type(void(0)), type(null), type([]), type({}) ] );
  alert( [ type(new Date), type(/h/g) ] );
</pre>
    <div class="runcase">Run</div>
    </div>

  </section>
  <section class="slide">
    <h1>实例 - call/apply</h1>
    <div class="codebox">
<pre>
  // 设置字体值.
  // 要求: 最大值为 200, 最小值为 100
  const FONT_SIZE_MIN_VALUE = 100;
  const FONT_SIZE_MAX_VALUE = 200;
  function setFontSize( value ) {
    value = Math.max.call( Math, FONT_SIZE_MIN_VALUE, value );
    value = Math.min.apply( Math, [FONT_SIZE_MAX_VALUE, value] );
    alert( value );
  }
  setFontSize( 120 );
  setFontSize( 50 );
  setFontSize( 240 );
</pre>
  <div class="runcase">Run</div>
  </div>
  </section>
  <section class="slide">
    <h1>变量作用域 - 闭包</h1>
    <p>函数产生作用域, 作用域链包裹变量 - 闭包.</p>
    <p>作用: 延长变量在内存中的时间. <a href="https://github.com/zhanhongtao/blog/issues/6" target="_blank">讨论此话题</a></p>
  <div class="codebox">
<pre contenteditable="true">
  function createCount(){
    var count = 1;
    return function() {
      return ++count;
    };
  }
  var count = createCount();
  count(); count(); // 3
  alert( count() ); // 4;
</pre>
  <div class="runcase">Run</div>
  </div>
  </section>
  <section class="slide">
    <h1>其它</h1>
    <ul>
      <li>只读 name 属性 - 返回函数名; 匿名函数返回空字符串</li>
      <li>arguments.callee 指向当前函数. 严格模式不再支持</li>
    </ul>
    <div class="codebox">
      <pre contenteditable="true">
function getName( user ) {
    alert( arguments.callee.name );
}
getName();
      </pre>
      <div class="runcase">Run</div>
    </div>
  </section>
  <section class="slide">
    <h1>其它</h1>
    <ul>
      <li>
        严格模式不支持 arguments.callee
    <div class="codebox">
<pre contenteditable="true">
'use strict';
function getName( user ) {
  try { var self = arguments.callee; }
  catch(e) {
    alert( 'error' );
  }
}
getName();
</pre>
      <div class="runcase">Run</div>
    </div>
      </li>
      <li>创建私有变量</li>
      <li>单元测试</li>
    </ul>
  </section>
  <section class="slide">
    <h1>其它 - 链式调用</h1>
    <div class="codebox">
<pre contenteditable="true">
  var _ = function( value ) {
    if ( value instanceof _ ) return value;
    if ( !(this instanceof _) ) return new _(value);
    this.core = value;
  };
  _.prototype.max = function() {
    return Math.max.apply( Math, this.core );
  };
  _.chain = function( value ) {
    return new _( value );
  };
  var max = _.chain( [1, 2, 5, 3] ).max();
  alert( max );
</pre>
    <div class="runcase">Run</div>
  </section>
  <section class="slide">
    <h1>其它 - 链式调用</h1>
      <div class="codebox">
<pre contenteditable="true">
  // 原理: 函数返回值存在方法
  [1, 2].map(function( item ) {
    return item * 2;
  }).forEach(function( item ) {
    alert( item );
  });
</pre>
        <div class="runcase">Run</div>
      </div>
  </section>
  <section class="slide">
    <h1>其它 - 递归</h1>
    <div data-run="1" class="codebox">
<pre contenteditable="true">
function flatArray( array ) {
  var i = 0, l = array.length, result = [], current;
  for ( ; i < l; i++ ) {
    current = array[i];
    // concat 支持单层合并.
    result = result.concat(type(current) ==='array' ?
        flatArray(current) : current );
  }
  return result;
}
alert( flatArray( [1,2,[3],[4,[5],6],7] ) );
</pre>
  <div class="runcase">Run</div>
  </div>
  </section>
  <section class="slide slide-cover">
    <h1>function !important</h1>
  </section>
  <section class="slide slide-cover">
    <h1>函数转换</h1>
  </section>
  <section class="slide">
    <h1>函数转换 - partial</h1>
    <p>不完全函数 - <a href="http://benalman.com/news/2012/09/partial-application-in-javascript/" target="_blank">更多</a></p>
    <div class="codebox">
<pre contenteditable="true">
  function partial( func ) {
    var argus = [].slice.call( arguments, 1 );
    return function() {
      return func.apply( this, argus.concat([].slice.call(arguments)) );
    };
  }
  var add = partial(function( a, b ) {
    return a + b;
  }, 5);
  alert( add(3) ); // 8
</pre>
      <div class="runcase">Run</div>
    </div>
  </section>
  <section class="slide">
    <h1>函数转换 - once</h1>
    <div class="codebox">
<pre contenteditable="true">
  function once( func ) {
    var flag, result;
    return function() {
      if ( flag ) return result;
      flag = true;
      result = func.apply( this, arguments );
      return result;
    };
  }
  var times = once(function() {alert( 1 );});
  times();times();
</pre>
      <div class="runcase">Run</div>
    </div>
  </section>
  <section class="slide">
    <h1>函数转换 - once</h1>
    <p>用途: 防止重复绑定事件 - jQuery</p>
<pre>
var bindEvents = once(function() {
  $( element ).on( 'click', function() {
    //...
  });
});
</pre>
  </section>
  <section class="slide">
    <h1>函数转换 - wrap</h1>
    <div class="codebox"></div>
<pre contenteditable="true">
function wrap( self, func ) {
  return function() {
    var _arguments = arguments;
    var next = function() {
      var argus = arguments.length ? arguments : _arguments;
      return self.apply( null, argus );
    };
    var argus = [].slice.call( arguments );
    var length = func.length;
    argus = length < 2 ? [] : argus.slice( 0, length - 1);
    argus.push( next );
    return func.apply( null, argus );
  };
}
</pre>
    <div class="runcase"></div>
  </section>
  <section class="slide">
    <h1>函数转换 - 面向切面</h1>
    <div class="codebox">
    <pre contenteditable="true">
function sendRequest( method ) {
  alert( 'request: ' + method );
  return 1;
}
sendRequest = wrap( sendRequest, function( next ) {
  alert( 'before request' );
  var result = next( 'POST' );
  alert( 'after request' );
  return result;
});
sendRequest(); // 1;
    </pre>
    <div class="runcase">Run</div>
    </div>
  </section>
  <section class="slide">
    <h1>函数转换 - 扩展方法</h1>
    <div class="codebox">
<pre contenteditable="true">
function $( selector ) {
  return document.querySelectorAll( selector );
};
$ = wrap( $, function(selector, next) {
  var core = next();
  return {
    each: function( func ) {
      for( var i = 0, l = core.length; i < l; i++ )
        func( core[i], i );
      return this;
    }
  };
});
$('.slide-cover').each(function(slide) {alert(slide.innerHTML)});
</pre>
    <div class="runcase">Run</div>
    </div>
  </section>
  <section class="slide">
    <h1>函数转换 - 模拟once</h1>
    <div class="codebox">
<pre contenteditable="true">
var a = function() { alert(1); }
a = wrap( a, function a( next ) {
  if ( a.tag ) return a.cache;
  a.tag = true;
  return a.cache = next();
});
a();
a();
</pre>
    <div class="runcase">Run</div>
    </div>
  </section>
  <section class="slide">
    <h1>函数转换 - 实用场景</h1>
    <p>短时间内(100ms)多次发生相同事件, 但仅需要执行最后一次.</p>
    <ul>
      <li>频繁点击按钮, 提交表单</li>
      <li>多次点击生成快捷方式按钮</li>
      <li>font-size-changed-event 同时发生多次</li>
      <li>blur和submit 提交操作, 两不同事触发同一操作</li>
      <li>频繁点击 ctrl + s 快捷键(?)</li>
    </ul>
  </section>
  <section class="slide">
    <h1>懒惰型函数</h1>
<pre>
function debounce( func, wait ) {
  var old = new Date;
  var timer;
  function ret() {
    if ( timer ) { clearTimeout( timer ); timer = null;}
    var argus = arguments;
    timer = setTimeout(function() {
      timer = null;
      func.apply( null, argus );
    }, wait);
  };
  return ret;
}
</pre>
  </section>
  <section class="slide">
    <h1>函数转换 - 实用场景</h1>
    <p>短时间内(100ms)n次发生相同事件, 但需要执行m(m<=n)次.</p>
    <ul>
      <li>window窗口 resize 时, 频繁重新渲染 DOM</li>
      <li>mousemove 事件频繁触发</li>
      <li>scroll 事件频繁触发</li>
      <li>扩展1: 网页中搜索建议, 发送的请求如何处理?</li>
      <li>扩展2: 如何防止表单重复提交?</li>
    </ul>
  </section>
  <section class="slide">
    <h1>节制性函数</h1>
    <a href="../scripts/throttle.js" target="_blank">查看源文件</a>
</pre>
  </section>
  <section class="slide">
    <h1>函数转换 - 实用场景</h1>
    <ul>
      <li>window7/8 Area 效果</li>
      <li>? hover 上以后等待100ms 后再显示帮助</li>
      <li>sogou图片搜索, 图片放大效果</li>
      <li>hover 来切换标签</li>
    </ul>
  </section>
  <section class="slide">
    <h1>函数转换 - 实用场景</h1>
    <ul>
      <li>需求: 按键盘 sogou 字符, 出现惊喜.</li>
      <li><a href="../html/after.html" target="_blank">实例</a></li>
    </ul>
  </section>
  <section class="slide">
    <h1>函数转换 - 实用场景</h1>
    <ul>
      <li>元素a, 从位置[0,0] 先移到到[0, 100], 再到[100, 100]</li>
      <li>需求: 对 n 个服务接口, 做单元测试.</li>
      <li>请求A数据, 根据A数据计算, 再请求B数据, 最后渲染页面.</li>
      <li><a href="../html/queue.html" target="_blank">动画实例</a></li>
    </ul>
  </section>
  <section class="slide">
    <h1>函数转换 - 实用场景</h1>
    <ul>
      <li>同时请求模板和数据, 计算结果, 渲染页面</li>
      <li><a href="../html/sync.html" target="_blank">动画实例</a></li>
      <li><a href="http://sketch.evanyou.me/async_asap.html" target="_blank">继续优化?x?</a></li>
    </ul>
  </section>
  <section class="slide">
    <h1>参考</h1>
    <ul>
      <li>权威指南 6</li>
      <li><a href="https://github.com/jashkenas/underscore/blob/master/underscore.js" target="_blank">underscore.js</a></li>
      <li><a href="http://caolanmcmahon.com/posts/flexible_callback_arguments/" target="_blank">flexible callback arguments</a></li>
      <li><a href="http://www.zhihu.com/question/19805411" target="_blank">如何防止重复提交?</a></li>
      <li><a href="http://osteele.com/sources/javascript/functional/" target="_blank">functional</a></li>
    </ul>
  </section>
  <section class="slide slide-cover">
    <h1>?</h1>
  </section>
  <nav id="navigator"></nav>
  <script src="./js/event.js"></script>
  <script src="./js/functional.js"></script>
  <script src="./js/hash.js"></script>
  <script src="./js/runcase.js"></script>
  <script src="./js/resize.js"></script>
  <script src="./js/pattern.js"></script>
  <script src="./js/ui.js"></script>
  <script src="./js/app.js"></script>
</body>
</html>